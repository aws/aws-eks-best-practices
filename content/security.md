# Security Pillar
The Security pillar includes the ability to protect information, systems, and assets while delivering business value through risk assessments and mitigation strategies.

## Definition
There are five best practice areas for Security in the cloud:

+ Identity and access management 
+ Detective controls
+ Infrastructure protection
+ Data protection
+ Incident response

Before you architect any system, you need to think about its security implications and the practices that can affect your security posture. For example, you need to control who can perform actions against a set of resources. You also need the ability to quickly identify security incidents, protect your systems and services from unauthorized access, and maintain the confidentiality and integrity of data through data protection. Having a well-defined and rehearsed process for responding to security incidents will help too. These tools and techniques are important because they support objectives such as preventing financial loss or complying with regulatory obligations.

AWS helps organizations achieve their security and compliance goals by offering a rich set of security services that have evolved based on feedback from a broad set of security conscious customers. By offering a highly secure foundation, customers can spend less time on “undifferentiated heavy lifting” and more time on achieving their business objectives. 

## Best Practices
### Identity and Access Management
Identity and Access Management (IAM) is an AWS service that performs 2 essential functions: Authentication and Authorization.  Authentication involves the verification of a indentity whereas authorization governs the actions that can be performed by AWS resources.  Within AWS, a resource can be another AWS service, e.g. EC2, or an AWS principle such as an IAM User or Role.  The rules governing the actions that a resource is allowed to peform are expressed as IAM policies.  

### Controlling Access to EKS Clusters
The Kubernetes project supports a variety of different strategies to authenticate requests to the kube-apiserver service, e.g. Bearer Tokens, X.509 certificates, OIDC, etc.  EKS currently has native support for [webhook token authentication](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication) and [serivce account tokens](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens).  

The webhook authentication strategy calls a webhook that verifies bearer tokens. On EKS, the bearer tokens are generated by the AWS CLI or the [aws-iam-authenticator](https://github.com/kubernetes-sigs/aws-iam-authenticator) client when you run `kubectl` commands. With each request, the token is passed to the kube-apiserver which forwards it to the authentication webhook.  If the request is well-formed, the webhook calls the pre-signed URL that's embedded in the token. This validates the request's signature and returns information about the user, e.g. the user's account, Arn, and UserId to the kube-apiserver.  

To generate a authentication token, type the following command in a terminal window: 
```
aws eks get-token --cluster <cluster_name>
```
The output should resemble this: 
```
{"kind": "ExecCredential", "apiVersion": "client.authentication.k8s.io/v1alpha1", "spec": {}, "status": {"expirationTimestamp": "2020-02-19T16:08:27Z", "token": "k8s-aws-v1.aHR0cHM6Ly9zdHMuYW1hem9uYXdzLmNvbS8_QWN0aW9uPUdldENhbGxlcklkZW50aXR5JlZlcnNpb249MjAxMS0wNi0xNSZYLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFKTkdSSUxLTlNSQzJXNVFBJTJGMjAyMDAyMTklMkZ1cy1lYXN0LTElMkZzdHMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIwMDIxOVQxNTU0MjdaJlgtQW16LUV4cGlyZXM9NjAmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JTNCeC1rOHMtYXdzLWlkJlgtQW16LVNpZ25hdHVyZT0yMjBmOGYzNTg1ZTMyMGRkYjVlNjgzYTVjOWE0MDUzMDFhZDc2NTQ2ZjI0ZjI4MTExZmRhZDA5Y2Y2NDhhMzkz"}}
```
Each token starts with `k8s-aws-v1.` followed by a base64 encoded string. The string, when decoded, should resemble this: 
```
https://sts.amazonaws.com/?Action=GetCallerIdentity&Version=2011-06-15&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJNGRILKNSRC2W5QA%2F20200219%2Fus-east-1%2Fsts%2Faws4_request&X-Amz-Date=20200219T155427Z&X-Amz-Expires=60&X-Amz-SignedHeaders=host%3Bx-k8s-aws-id&X-Amz-Signature=220f8f3585e320ddb5e683a5c9a405301ad76546f24f28111fdad09cf648a393
```
The token consists of a pre-signed URL that includes an Amazon credential and signature. For additional see https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html. 

The token has a time to live (TTL) of 15 minutes after which a new token will need to be generated. This is handled automatically  when you use a client like `kubectl` but if you're using the Kubernetes dashboard, you will need to generate a new token and re-authenticate once every 15 minutes. 

Once the user's identity has been authenticated by the AWS IAM service, the kube-apiserver reads the `aws-auth` ConfigMap in the kube-system namespace to determine the RBAC group to associate with that user.  The `aws-auth` ConfigMap is used to create a static mapping betweeen IAM principles (Users and Roles) and Kubernetes RBAC groups. RBAC groups can be referenced in Kubernetes RoleBindings or ClusterRoleBindings. They are similar to IAM Roles in that they define a set of actions (verbs) that can be peformed against Kubernetes resources (objects).

#### Recommendations
+ **Don't use a service account token for authentication**. A service account token is a long-lived credential. If it is compromised, lost, or stolen, an attacker may be able to perform all the actions associated with that token until the service account is deleted. You may need to grant an exception for applications that access the Kubernetes API from outside the cluster, e.g. a CI/CD pipeline. If such applications run on AWS infrastructure, like EC2, consider using an instance profile and mapping that to a RBAC role instead.  

+ **Employ least privileged access to AWS Resources**. An IAM User does not need to be assigned privileges to AWS resources to access the Kubernetes API. If you need to grant an IAM user access to an EKS cluster, create an entry in the aws-auth ConfigMap for that user that maps to a specific Kubernetes RBAC group. 

+ **Use IAM Roles when multiple users need identical access to the cluster**. Rather than creating an entry for each individual IAM User in the aws-auth ConfigMap, allow those users to assume an IAM Role and map that role to a Kubernetes RBAC group.  This will be easier to maintain, especially as the number of users that require access to the grows.

+ **Employ least privilieged access when creating RoleBindings and ClusterRoleBindings**. Like the early point about granting access to AWS Resources, RoleBindings and ClusterRoleBindings should only include the set of permissions necessary to perform a specific function. Avoid using ["*"] in your Roles and ClusterRoles unless it's absolutely necessary. If you're unsure what permissionss to assign, consider using a tool like [audit2rbac](https://github.com/liggitt/audit2rbac) to automatically generate Roles and binding based on the observed API calls in the Kubernetes Audit Log.

+ **Regularly audit access to the cluster**. Who requires access is likely to change over time. Periodically review the aws-auth ConfigMap to see who has been granted access and the rights they've been assigned. You can also use open source tooling like [kubectl-who-can](https://github.com/aquasecurity/kubectl-who-can), or [rbac-lookup](https://github.com/FairwindsOps/rbac-lookup) to see the roles bound to a service account, user, or group. We'll explore this topic further when we get to auditing.

+ **Make the EKS Cluster Endpoint private**. By default when you provision an EKS cluster, the API cluster endpoint is set to public, i.e. it can be accessed from the Internet. Despite being public, the endpoint is secure because it requires that all API requests are authenticated and authorized. If your security policy mandates that you restrict access to the API from the Internet or prevents traffic frmo being routed outside the cluster VPC, you can: 
    + Configure the EKS cluster endpoint to be private. See [Modifying Cluster Endpoint Access](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html) for further information on this topic. 
    + Leave the cluster endpoint public and specify which CIDR blocks can communicate with the cluster endpoint. The blocks are effectively a whitelisted set of public IP addresses that are allowed to access the cluster endpoint.
    + Configure public access with a set of whitelisted CIDR blocks and set private endpoint access to enabled. This will allow public access from a specific range of public IPs and force all network traffic between the kubelets (workers) and the Kubernetes API through the cross-account ENIs that get provisioned in the cluster VPC.

#### Alternative Approaches to Authentication and Access Management
While IAM is the preferred way to authenticate users who need access to an EKS cluster, it is possible to use an OIDC identity provider such as GitHub using an authentication proxy and Kubernetes [impersonation](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation). Posts for 2 such solutions have been published on the AWS Open Source blog:
+ [Authenticating to EKS Using GitHub Credentials with Teleport](https://aws.amazon.com/blogs/opensource/authenticating-eks-github-credentials-teleport/)
+ [Consistent OIDC authentication across multiple EKS clusters using kube-oidc-proxy](https://aws.amazon.com/blogs/opensource/consistent-oidc-authentication-across-multiple-eks-clusters-using-kube-oidc-proxy/)

You can also use [AWS SSO](https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html) to federate AWS with an external identity provider, e.g. Azure AD. If you decide to use this option, the AWS CLI v2.0 includes an option to create a named profile that makes it easy to associate an SSO session with your current CLI session and assume an IAM role. You must assume a role prior to running `kubectl` as the IAM role is used to determine the user's Kubernetes RBAC group.
